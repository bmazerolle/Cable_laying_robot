#pragma config(Sensor, in4,    IRsensorLeft,      sensorReflection)
#pragma config(Sensor, in3,    IRsensorRight,      sensorReflection)
#pragma config(Sensor, dgtl3,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl9,  startButton,    sensorTouch)
#pragma config(Sensor, dgtl10, leftFrontButton, sensorTouch)
#pragma config(Sensor, dgtl11, frontButton,    sensorTouch)
#pragma config(Sensor, dgtl12, rightFrontButton, sensorTouch)
#pragma config(Motor,  port1,           RightMotor,    tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port10,          LeftMotor,     tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool startButton_pushed; //True if start button has been pressed
bool frontButton_pushed; //True if front limit switch has been pressed
bool leftFrontButton_pushed; //True if front left button has been pressed
bool rightFrontButton_pushed; //True if front right button has been pressed
bool sonarCollision; //True if sonar sensor on robot back reads distance less than 8cm
bool facingBeacon; //True if robot is facing beacon
bool closeToBeacon; //True if robot is getting close to beacon
bool facingClose; //True if robot is facing the beacon at a close distance
bool connection; //True if robot is at right distance for connection
bool reset = true; //Timer to pause robot at start

const int light_threshold = 300; //Threshold for beacon visibility
const int close_threshold = 3300; //Threshold for close proximity to beacon
const int connection_threshold = 3830; //Threshold for correct connection distance
const int search_difference_threshold = 650; //Threshold for difference in IRLeft and IRRight readings when searching for beacon
const int close_difference_threshold = 1500; //Threshold for difference in IRLeft and IRRight readings when close to beacon

//Function to monitor button inputs
void monitorInput()
{
	if(SensorValue(startButton) && !startButton_pushed)
  {
    startButton_pushed = true; //Monitors pressing of start button
  }

  if(SensorValue(frontButton) && !frontButton_pushed)
  {
    frontButton_pushed = true; //Monitors pressing of front limit switch
  }

  if(SensorValue(leftFrontButton) && !leftFrontButton_pushed)
  {
    leftFrontButton_pushed = true; //Monitors pressing of left front button
  }

  if(SensorValue(rightFrontButton) && !rightFrontButton_pushed)
  {
  	rightFrontButton_pushed = true; //Monitors pressing of right front button
	}

	if(SensorValue[sonarSensor] < 8 && SensorValue[sonarSensor] >= 0 && !sonarCollision)
	{
		sonarCollision = true; //Monitors sonar measurement of distances closer than 8cm
	}
}//end monitorInput()




//Function to search for beacon from any distance
bool monitorLight()
{
	static int minLevelIRLeft = 4096;  	// Minimum light level seen by Left IR sensor
	static int maxLevelIRLeft = 0;			// Maximum light level seen by Left IR sensor
	static int diffLevelIRLeft = 0;		  // Delta between maximum and minimum IR Left readings in past 0.02 seconds
	static int minLevelIRRight = 4096;	// Minimum light level seen by Right IR sensor
	static int maxLevelIRRight = 0;			// Maximum light level seen by Right IR sensor
	static int diffLevelIRRight = 0;		// Delta between maximum and minimum IR Right readings in past 0.02 seconds

	//Assign IR Readings to integer variables
	int lightLevelLeft = SensorValue[IRsensorLeft];
	int lightLevelRight = SensorValue[IRsensorRight];
	bool returnValue;

	// Check if 20 msecs have elapsed.
	if ( time1[T1] > 20 )  {

		//Pause for 100ms at start of program to prevent VEX cortex power surge
		if ( reset ) {
	  	wait1Msec(100);
	  	diffLevelIRLeft = 0;
	  	diffLevelIRRight = 0;
	  	reset = false;
	  } else {
	  // 20 msecs have elapsed.  Compute delta of light level.
			diffLevelIRLeft = maxLevelIRLeft - minLevelIRLeft;
			diffLevelIRRight = maxLevelIRRight - maxLevelIRRight;
		}
		// Reset calculation for next 20 msecs.
		maxLevelIRLeft = 0;
		minLevelIRLeft = 4096;
		maxLevelIRRight = 0;
		minLevelIRRight = 4096;
		clearTimer(T1);

	} else {

	  // Check for new minimum/maximum light levels of Left IR Sensor
	  if ( lightLevelLeft < minLevelIRLeft ) {
	  	minLevelIRLeft = lightLevelLeft;
	  } else if ( lightLevelLeft > maxLevelIRLeft ) {
	    maxLevelIRLeft = lightLevelLeft;
	  }

	  // Check for new minimum/maximum light levels of Right IR Sensor
	  if ( lightLevelRight < minLevelIRRight ) {
	  	minLevelIRRight = lightLevelRight;
	  } else if ( lightLevelRight > maxLevelIRRight ) {
	    maxLevelIRRight = lightLevelRight;
	  }
	}

	// Check if light level difference over threshold and difference between readings is under difference threshold
	if (((diffLevelIRLeft>light_threshold)||(diffLevelIRRight>light_threshold))&&(abs((diffLevelIRLeft)-diffLevelIRRight)<search_difference_threshold)) {
		returnValue = true;
	} else {
	  returnValue = false;
	}
	return(returnValue);
}//end monitorLight()



bool monitorClose()
{
	static int minLevelIRLeft = 4096;  	// Minimum light level seen by Left IR sensor
	static int maxLevelIRLeft = 0;			// Maximum light level seen by Left IR sensor
	static int diffLevelIRLeft = 0;		  // Delta between maximum and minimum IR Left readings in past 0.02 seconds
	static int minLevelIRRight = 4096;	// Minimum light level seen by Right IR sensor
	static int maxLevelIRRight = 0;			// Maximum light level seen by Right IR sensor
	static int diffLevelIRRight = 0;		// Delta between maximum and minimum IR Right readings in past 0.02 seconds

	//Assign IR Readings to integer variables
	int lightLevelLeft = SensorValue[IRsensorLeft];
	int lightLevelRight = SensorValue[IRsensorRight];
	bool returnCloseValue;

	// Check if 20 msecs have elapsed.
	if ( time1[T1] > 20 )  {

		//Pause for 100ms at start of program to prevent VEX cortex power surge
		if ( reset ) {
	  	wait1Msec(100);
	  	diffLevelIRLeft = 0;
	  	diffLevelIRRight = 0;
	  	reset = false;
	  } else {
	  // 20 msecs have elapsed.  Compute delta of light level.
			diffLevelIRLeft = maxLevelIRLeft - minLevelIRLeft;
			diffLevelIRRight = maxLevelIRRight - maxLevelIRRight;
		}

		// Reset calculation for next 20 msecs.
		maxLevelIRLeft = 0;
		minLevelIRLeft = 4096;
		maxLevelIRRight = 0;
		minLevelIRRight = 4096;
		clearTimer(T1);

	} else {

	  // Check for new minimum/maximum light levels of Left IR Sensor
	  if ( lightLevelLeft < minLevelIRLeft ) {
	  	minLevelIRLeft = lightLevelLeft;
	  } else if ( lightLevelLeft > maxLevelIRLeft ) {
	    maxLevelIRLeft = lightLevelLeft;
	  }

	  // Check for new minimum/maximum right levels of Left IR Sensor
	  if ( lightLevelRight < minLevelIRRight ) {
	  	minLevelIRRight = lightLevelRight;
	  } else if ( lightLevelRight > maxLevelIRRight ) {
	    maxLevelIRRight = lightLevelRight;
	  }
	}

	// Check if either light level difference over close threshold.
	if ((diffLevelIRLeft+1300 > close_threshold)||(diffLevelIRRight > close_threshold)) {
		returnCloseValue = true;
	} else {
	  returnCloseValue = false;
	}
	//return true when robot close to target
	return(returnCloseValue);
}//end monitorClose()



bool monitorOrientationClose()
{
	static int minLevelIRLeft = 4096;  	// Minimum light level seen by Left IR sensor
	static int maxLevelIRLeft = 0;			// Maximum light level seen by Left IR sensor
	static int diffLevelIRLeft = 0;		  // Delta between maximum and minimum IR Left readings in past 0.02 seconds
	static int minLevelIRRight = 4096;	// Minimum light level seen by Right IR sensor
	static int maxLevelIRRight = 0;			// Maximum light level seen by Right IR sensor
	static int diffLevelIRRight = 0;		// Delta between maximum and minimum IR Right readings in past 0.02 seconds

	//Assign IR Readings to integer variables
	int lightLevelLeft = SensorValue[IRsensorLeft];
	int lightLevelRight = SensorValue[IRsensorRight];
	bool returnCloseValue;

	// Check if 20 msecs have elapsed.
	if ( time1[T1] > 20 )  {

	//Pause for 100ms at start of program to prevent VEX cortex power surge
	if ( reset ) {
	  	wait1Msec(100);
	  	diffLevelIRLeft = 0;
	  	diffLevelIRRight = 0;
	  	reset = false;
	  } else {
	  // 20 msecs have elapsed.  Compute delta of light level.
			diffLevelIRLeft = maxLevelIRLeft - minLevelIRLeft;
			diffLevelIRRight = maxLevelIRRight - maxLevelIRRight;
		}
		// Reset calculation for next 20 msecs.
		maxLevelIRLeft = 0;
		minLevelIRLeft = 4096;
		maxLevelIRRight = 0;
		minLevelIRRight = 4096;
		clearTimer(T1);

	} else {

	  // Check for new minimum/maximum light levels of Left IR Sensor
	  if ( lightLevelLeft < minLevelIRLeft ) {
	  	minLevelIRLeft = lightLevelLeft;
	  } else if ( lightLevelLeft > maxLevelIRLeft ) {
	    maxLevelIRLeft = lightLevelLeft;
	  }

	  // Check for new minimum/maximum light levels of Right IR Sensor
	  if ( lightLevelRight < minLevelIRRight ) {
	  	minLevelIRRight = lightLevelRight;
	  } else if ( lightLevelRight > maxLevelIRRight ) {
	    maxLevelIRRight = lightLevelRight;
	  }
	}

	// Check if light level difference over close threshold and difference between readings is less than the close difference threshold.
	if (((diffLevelIRLeft > close_threshold)||(diffLevelIRRight > close_threshold))&&(abs((diffLevelIRLeft)-diffLevelIRRight)>close_difference_threshold)) {
		returnCloseValue = true;
	} else {
	  returnCloseValue = false;
	}
	//return true if robot oriented correctly when close to target
	return(returnCloseValue);
}//end monitorOrientationClose()




bool monitorConnection()
{
	static int minLevelIRLeft = 4096;  	// Minimum light level seen by Left IR sensor
	static int maxLevelIRLeft = 0;			// Maximum light level seen by Left IR sensor
	static int diffLevelIRLeft = 0;		  // Delta between maximum and minimum IR Left readings in past 0.02 seconds
	static int minLevelIRRight = 4096;	// Minimum light level seen by Right IR sensor
	static int maxLevelIRRight = 0;			// Maximum light level seen by Right IR sensor
	static int diffLevelIRRight = 0;		// Delta between maximum and minimum IR Right readings in past 0.02 seconds

	//Assign IR Readings to integer variables
	int lightLevelLeft = SensorValue[IRsensorLeft];
	int lightLevelRight = SensorValue[IRsensorRight];
	bool returnConnectionValue;

	// Check if 20 msecs have elapsed.
	if ( time1[T1] > 20 )  {

	//Pause for 100ms at start of program to prevent VEX cortex power surge
	if ( reset ) {
	  	wait1Msec(100);
	  	diffLevelIRLeft = 0;
	  	diffLevelIRRight = 0;
	  	reset = false;
	  } else {
	  // 20 msecs have elapsed.  Compute delta of light level.
		diffLevelIRLeft = maxLevelIRLeft - minLevelIRLeft;
		diffLevelIRRight = maxLevelIRRight - minLevelIRRight;
		}
		// Reset calculation for next 20 msecs.
		maxLevelIRLeft = 0;
		minLevelIRLeft = 4096;
		maxLevelIRRight = 0;
		minLevelIRRight = 4096;
		clearTimer(T1);

	} else {

	  // Check for new minimum/maximum light levels of Left IR Sensor
	  if ( lightLevelLeft < minLevelIRLeft ) {
	  	minLevelIRLeft = lightLevelLeft;
	  } else if ( lightLevelLeft > maxLevelIRLeft ) {
	    maxLevelIRLeft = lightLevelLeft;
	  }

	  // Check for new minimum/maximum light levels of Right IR Sensor
	  if ( lightLevelRight < minLevelIRRight ) {
	  	minLevelIRRight = lightLevelRight;
	  } else if ( lightLevelRight > maxLevelIRRight ) {
	    maxLevelIRRight = lightLevelRight;
	  }
	}

	// Check if either light level difference over connection threshold.
	if ((diffLevelIRLeft > connection_threshold)||(diffLevelIRRight > connection_threshold)) {
		returnConnectionValue = true;
	} else {
	  returnConnectionValue = false;
	}
	//return true if robot is at right distance for connection
	return(returnConnectionValue);
}//end monitorConnection()




void operation(){

typedef enum SystemStateType{
	ForwardState,
	CloseState,
	ConnectionState,
	SearchState,
	SeenState,
	FrontCollision,
	LeftFrontCollision,
	RightFrontCollision,
	BackCollision,
	IdleState,
} SystemStateType;

SystemStateType SystemState = IdleState;

	while(true)
	{
	monitorInput(); //Monitor button input
	facingBeacon = monitorLight(); //Monitor robot orientation to beacon from any distance
	closeToBeacon = monitorClose();  //Monitor if robot close to beacon (approximately 50 cm)
	facingClose = monitorOrientationClose(); //Monitor robot orientation to beacon from close distance
	connection = monitorConnection(); //Monitor if robot is close enough for connection


		switch(SystemState){

		case IdleState:
		//Motors off
 		motor[LeftMotor] = 0;
 		motor[RightMotor] = 0;
 		//When the start button is pressed, enter the search state
 		if(startButton_pushed == true){
 			SystemState = SearchState;
 			break;
 		}
 		//Reset boolean for further reading
 		startButton_pushed = false;
 		break;


 		case SearchState:
 		//Left motor rotates backward, Right motor rotates forward
 		motor[LeftMotor] = -40;
 		motor[RightMotor] = 40;
 		//If the left front button is pushed, enter the LeftFrontCollision State
 		if(leftFrontButton_pushed == true){
 			SystemState = LeftFrontCollision;
 		}
 		//If the right front button is pushed, enter the RightFrontCollision State
 		if(rightFrontButton_pushed == true){
 			SystemState = RightFrontCollision;
 		}
 		//If the front button is pushed, enter the FrontCollision State
 		if(frontButton_pushed == true){
 			SystemState = FrontCollision;
 		}
 		//If the robot's rear SONAR sensor reads a value lower than 8cm, enter the BackCollision State
 		if(sonarCollision == true){
 			SystemState = BackCollision;
 		}
 		//If the robot locates the beacon, enter the Seen State
 		else if(facingBeacon == true){
 			SystemState = SeenState;
 		}
 		break;

 		case SeenState:
 		//Motors off for .25s
 		motor[LeftMotor] = 0;
 		motor[RightMotor] = 0;
 		wait1Msec(250);
 		//Enter the Forward State
 		SystemState = ForwardState;
 		break;


 		case ForwardState:
 		//Motors both rotating forward
 		motor[LeftMotor] = 70;
 		motor[RightMotor] = 70;
 		//If the left front button is pushed, enter the LeftFrontCollision State
 		if(leftFrontButton_pushed == true){
 			SystemState = LeftFrontCollision;
 		}
 		//If the right front button is pushed, enter the RightFrontCollision State
 		if(rightFrontButton_pushed == true){
 			SystemState = RightFrontCollision;
 		}
 		//If the front button is pushed, enter the FrontCollision State
 		if(frontButton_pushed == true){
 			SystemState = FrontCollision;
 		}
 		//If the robot's rear SONAR sensor reads a value lower than 8cm, enter the BackCollision State
 		if(sonarCollision == true){
 			SystemState = BackCollision;
 		}
 		//If the IR sensors detect that the robot is close (approx. 50cm) to the beacon, enter the Close State
 		else if(closeToBeacon == true){
 			SystemState = CloseState;
 		}
 		//Reset boolean for further reading
 		facingBeacon = false;
 		break;

 		case CloseState:
 		//Motors rotating forward slowly
 		motor[LeftMotor] = 25;
 		motor[RightMotor] = 25;
 		//If the left front button is pushed, enter the LeftFrontCollision State
 		if(leftFrontButton_pushed == true){
 			SystemState = LeftFrontCollision;
 		}
 		//If the right front button is pushed, enter the RightFrontCollision State
 		if(rightFrontButton_pushed == true){
 			SystemState = RightFrontCollision;
 		}
 		//If the front button is pushed, enter the FrontCollision State
 		if(frontButton_pushed == true){
 			SystemState = FrontCollision;
 		}
 		//If the robot's rear SONAR sensor reads a value lower than 8cm, enter the BackCollision State
 		if(sonarCollision == true){
 			SystemState = BackCollision;
 		}
 		//If the robot loses sight of the beacon, maintain forward motion for .35s
 		if(facingClose == false){
 			wait1Msec(350);
 				//If the robot still does not see the beacon, enter the Search State
 				if(facingClose == false){
 					SystemState = SearchState;
 				}
 		}
 		//If the robot is within a distance for a connection, enter the Connection State
 		else if(connection == true){
 			SystemState = ConnectionState;
 		}
 		//Reset boolean for further reading
 		closeToBeacon = false;
 		break;

 		case ConnectionState:
 		//Motors rotate backwards quickly for .5s
 		motor[LeftMotor] = -70;
 		motor[RightMotor] = -70;
 		wait1Msec(500);
 		//Left motor rotates forward, right motor rotates backwards for .5s
 		motor[LeftMotor] = 40;
 		motor[RightMotor] = -40;
 		wait1Msec(500);
 		//Motors rotate backwards quickly for .5s
 		motor[LeftMotor] = -70;
 		motor[RightMotor] = -70;
 		wait1Msec(500);
 		//Reset boolean for further reading
 		startButton_pushed = false;
 		//Enter the Idle State
 		SystemState = IdleState;
		break;

 		case FrontCollision:
 		//If the robot can see the beacon, a connection has been made; enter the Connection State
 		if((facingClose == true)||(facingBeacon == true)||(closeToBeacon==true)){
 			SystemState = ConnectionState;
 			break;
 		}
 		//Rotate both motors backwards for .5s
 		motor[LeftMotor] = -50;
 		motor[RightMotor] = -50;
 		wait1Msec(500);
 		//Reset boolean for further reading
 		frontButton_pushed = false;
 		//Enter the Search State
 		SystemState = SearchState;
 		break;

 		case LeftFrontCollision:
 		//Rotate both motors backwards for .5s
 		motor[LeftMotor] = -50;
 		motor[RightMotor] = -50;
 		wait1Msec(500);
 		//Rotate the left motor backwards and right motor forwards for .5s
 		motor[LeftMotor] = -50;
 		motor[RightMotor] = 50;
 		wait1Msec(500);
 		//Reset boolean for further reading
 		leftFrontButton_pushed = false;
 		//Enter the Search State
 		SystemState = SearchState;
 		break;

 		case RightFrontCollision:
 		//Rotate both motors backwards for .5s
 		motor[LeftMotor] = -50;
 		motor[RightMotor] = -50;
 		wait1Msec(500);
 		//Rotate the right motor backwards and left motor forwards for .5s
 		motor[LeftMotor] = 50;
 		motor[RightMotor] = -50;
 		wait1Msec(500);
 		//Reset boolean for further reading
 		rightFrontButton_pushed = false;
 		//Enter the Search State
 		SystemState = SearchState;
 		break;

 		case BackCollision:
 		//Rotate both motors forwards for .5s
 		motor[LeftMotor] = 50;
 		motor[RightMotor] = 50;
 		wait1Msec(500);
 		//Reset boolean for further reading
 		sonarCollision = false;
 		//Enter the Search State
 		SystemState = SearchState;
 		break;

 		default: //Will never go here
 		motor[RightMotor] = 0;
 		motor[LeftMotor] = 0;
 		break;
		}//End switch
	}//End while
}//End operation()


task main()
{
	//Set all booleans to false
	startButton_pushed = frontButton_pushed = leftFrontButton_pushed = rightFrontButton_pushed = sonarCollision = false;
	connection = facingBeacon = facingBeacon = false;
	//Enter the robot operation function
	operation();

}//End main
